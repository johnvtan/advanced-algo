Team Members: John Tan, Emerson Boyd
KNAPSACK
Our greedy knapsack algorithm determines the ratio between the value and cost of each item to decide which item to put in the knapsack. On each iteration, the algorithm will find the item with the highest value/cost ratio, check if the item fits in the knapsack, and if it does, selects the item. If the item puts the knapsack over the cost limit, then we mark the value/cost ratio as -1 to ensure that it is never chosen as the item with the maximum value/cost ratio.

The worst-case performance of this algorithm is O(n^2). If every item fits in the knapsack without going over the cost limit, then it will select every item which is O(n). For each item, the algorithm will also determine the item with the max value/cost ratio, which is done by simply examining the value/cost ratio sequentially, so it also runs in O(n). Since finding the max ratio is nested within the outer loop, together the performance is O(n^2).

In comparison to the exhaustive search algorithm, our greedy knapsack algorithm works much better at higher input sizes at the expense of accuracy at lower input sizes. For example, at input size 8, our exhaustive algorithm finds a knapsack with a value of 2192 at cost 1592 while the greedy algorithm finds a sub-optimal solution with value 1986 and cost 1386. However, at input sizes 48 and above, the greedy algorithm outperforms the exhaustive search. At size 48, the exhaustive algorithm finds a solution with value 13411 with cost 11111 but the greedy algorithm finds a better solution with value 14141 and cost 10741. In addition, the exhaustive algorithm was given 10 minutes to run while the greedy algorithm ran in less than a second even at higher input sizes, demonstrating the property of the greedy algorithm to run both quickly and relatively effectively at very large input sizes.

COLORING
Our greedy coloring algorithm prioritizes vertex coloring by descending order of degree (the node with the most edges is prioritized first). It finds the node with the highest degree that has yet to be colored and has at least one legal color in its domain (meaning that the node won't create conflicts). The algorithm then colors that new node whatever legal color is possible. After looping through all possible nodes, all of the remaining nodes that cannot be colored due to conflicts are counted, and that is the least number of conflicts determined by our algorithm. This algorithm represents the classical greedy algorithm in that it colors node by ordering the nodes first, then selecting the ones that haven't been selected and don't cause conflicts.

The performance of this algorithm is O(n^3) with respect to the amount of vertices/edges. The reason behind this performance is that the algorithm, in the worst case, colors each node once, which takes O(n) time. In the process of coloring a single node, it loops through every node in the graph to find the node with the highest degree that has not been selected yet, which would also take O(n) time. In the process of finding the node with the highest degree, the current node's edges must be looped through in order to count the number of edges leaving that node, which takes O(n) time. The three nested loops ultimately results in an operation time of O(n^3).

However, the runtime of O(n^3) is still far superior to the exponential runtime for the exhaustive algorithm. All input files run virtually instantaneously with this greedy algorithm, while many of the input files did not finish in 10 minutes with the exhaustive approach. While the input of size 12 had the same number of conflicts with both algorithms, the advantage of the greedy algorithm becomes apparent with input sizes of 24 and up. The greedy algorithm is able to create far fewer conflicts for all input files of size 24 and up.

