Team Members: John Tan, Emerson Boyd

Our branch and bound algorithm for the knapsack problem branches on selecting or not selecting each item. The bound is calculated by adding items with the highest value/cost ratio to the knapsack until no more items can fit, then taking a fraction of the item with the next highest value/cost ratio to fill the remaining space. 

Our implementation starts by creating two partial solutions by branching on the first item. One partial solution has selected the first item, the other did not select the item. Then the upper bounds of each of these partial solutions are calculated and we explore the partial solution with the higher upper bound. When we explore a partial solution, we spawn two child solutions - one where this partial solution selects the next item, and one where it does not. If the new partial solution that selects the item exceeds the cost bound, it is immediately removed. We then add the valid partial solutions to our list containing all partial solutions that still need to be explored. We then find the partial solution in the list that has the highest upper bound and repeat this process.

Once we arrive at a complete solution, we can begin pruning partial solutions. Any partial solution that has an upper bound that is less than or equal to the value of our best solution is removed from the list. Similarly, if we arrive at a complete solution whose value is worse than our current best solution, then that solution is thrown out. Otherwise, if the new complete solution has a greater value than our previous best, we update our best solution to be the new one.

Because this algorithm in the worst case has to search through every single possible solution, which is every possible subset of the items, it has an exponential worst-case runtime of O(2^n). However, due to the process of pruning partial solutions, it should on average have a lower runtime. 

In practice, this branch and bound solution runs slower than the greedy algorithm in all cases as well as the exhaustive algorithm at lower instance sizes. Since the branch and bound algorithm must search through all the partial solutions to find the one with the highest upper bound and spend time pruning solutions, it has a high constant factor which explains why it performs worse than exhaustive search at lower instances. 