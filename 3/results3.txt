Team Members: John Tan, Emerson Boyd

KNAPSACK
The ILP formulation for the knapsack problem is relatively straightforward from the knapsack problem statement. Given the cost bound, value vector, and cost vector for all the items, we want to maximize the value of the chosen items without exceeding the cost bound. So we create a binary vector x where x[i] is 1 if item i is selected for the knapsack. This allows us to create our objective, which is the sum over x[i] * value[i], which is the total value of the items in our knapsack that we want to maximize. We set a single constraint which ensures that the cost of the items in our bag is less than or equal to the cost bound.

Although ILP is an NP-Complete problem, the solver we used solved all of the instances of knapsack extremely quickly. None of the instances approached the 10 minute limit set on the solver - every instance was solved in well under one second. This demonstrates that even though the solver has an exponential worst-case run time, it can still solve some large problem instances extremely quickly. This may be due in part to the simplicity of the knapsack formulation, since it only had one variable and one constraint.

While at smaller instances the ILP solution and exhaustive solution converged to the same total value, the ILP solution began to yield a greater value by instance size 48. Furthermore, the ILP solution seemed to have outperformed the greedy solution across the board by yielding a higher value at both small and large instances. In addition, the ILP solution ran very quickly across all instance sizes, which was similar to the greedy algorithm while improving on its performance. 

COLORING
Our ILP coloring solution maintains three matrices to keep track of: edges between nodes (size n by n), colors of nodes (size n by c), and conflicts between nodes (size n by n). Our constraint on the conflicts is designed to cause the conflict cell to be a value of 1 if there is a conflict, and unconstrained if there is no conflict. Because our algorithm tries to minimize the value of the conflicts, if the conflicts remain unconstrained, they will get evaluated to zero.

Because we maintain a binary matrix of coloring assignments, rather than an integer vector to denote each node's color, we add an extra dimension that the solver must take into account. Because the solver has to process three 2D structures instead of two 2D structures and one 1D structure, we do add some inefficiency to the solver. This could be potentially fixed by changing the coloring assignments to use a vector rather than a matrix, and might cause the input files of larger sizes to run in under 10 minutes.

Ultimately, it is difficult to measure the exact performance of this ILP solution, as we do not know how the CPLEX algorithm optimizes its solution process, but there is always room for improvement by reducing the dimensionality of our variables.

In terms of performance against other methods (exhaustive and greedy algorithms), it performs well in several scenarios. When comparing these results to the exhaustive approach, we see that it runs faster than the exhaustive approach as the input file size gets larger. In addition, the ILP solution runs equally as fast as the greedy algorithm for inputs of small size. For inputs of large size that has at least one conflict, it performs  better than the greedy algorithm when limited to ten minutes. For example, the 192-6 input file got 8 conflicts with the greedy algorithm, while the same input file had 4 conflicts with the ILP solution after the 10-minute timeout.
