For the knapsack algorithm, we exhaustively test every possible 
subset of items and keep track of the highest-valued subset 
that has a legal cost. The performance of this algorithm is 
not ideal, as there are 2^n subsets for n total items, meaning 
that we have to deselect and reselect all items 2^n times, 
which takes exponential time. Although we take exponential time, 
memory use is mostly linear with n items for our program, 
because we calculate each subset of items incrementally using 
an iterator, rather than calculating all of the subsets at the 
beginning of the program and retaining them in memory.

For the coloring algorithm, we exhaustively test every possible 
combination of colors in the graph and keep track of the lowest 
number of conflicts that come from our testing. Because we 
calculate every single possible combination of colorings, the 
runtime of our algorithm is O(m^n), where m is the number of 
colors and n is the number of nodes. Similar to our knapsack 
algorithm, memory use is linear with the amount of nodes because 
we incrementally determine the next colors rather than retaining 
all possible color combinations at the beginning of code execution.

Our algorithms work well for input files of small size, but 
as the input file size increases, the runtime of our algorithm 
quickly reaches the 10-minute maximum. This timeout is an expected 
result of the exponential nature of the exhaustive algorithms.